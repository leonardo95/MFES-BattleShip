class Board
types
	public Cells = set of CellBoard;
values
	public static BoardSize: int = 10;
	public static rangeCells: set of int = {1, ..., BoardSize};
	
	-- Shot types
	public static Shot_Miss: char = 'M';
	public static Shot_Hit: char = 'H';
	public static Shot_DestroyedShip: char = 'D';
	
	
instance variables

	public boardCells: Cells;
	-- If battleShipBoard is 0, registers the shots of my enemy at my board (down board)
	-- If battleShipBoard is 1, registers my shots on the board of my enemy (top board)
	public battleShipBoard: int;
	
	inv card(boardCells) >= 1;
	
operations
	public Board: int ==> Board
		Board(BoardType) ==
		(
			boardCells := {};
			battleShipBoard := BoardType;
			
			for all cells_x in set rangeCells do (
				for all cells_y in set rangeCells do (
					boardCells := boardCells union {new CellBoard(cells_x, cells_y)};
					)
				);
				
				for all boardcells in set boardCells do
					boardcells.setBoard(self);
		)
		post card(boardCells) = BoardSize * BoardSize;
		
		public strike: seq of int ==> char
			strike(coordinates) ==
			(
				let cell in set boardCells be st(cell.x_coord = hd coordinates and cell.y_coord = hd(tl coordinates)) in (
				
				if not cell.withShip or cell.striked then 
					return Shot_Miss;
				
				if cell.withShip and not cell.striked then (
					cell.sethit();
					cell.ship.incStrikes();
				);
				
				if cell.ship.getShipStatus() then 
					return Shot_DestroyedShip;
					
				return Shot_Hit;
				);
			)
			pre CellBoard`verifyCoordinates(coordinates)
			post RESULT in set {Shot_Miss, Shot_Hit, Shot_DestroyedShip};
			
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Board